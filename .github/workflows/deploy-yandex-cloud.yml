name: Deploy to Yandex Cloud

on:
  push:
    branches: [ main, master ]
    paths: 
      - 'backend/**'
      - '.github/workflows/deploy-yandex-cloud.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: 'false'

env:
  REGISTRY_ID: ${{ secrets.YC_REGISTRY_ID }}
  VM_NAME: hsk-backend
  IMAGE_TAG: cr.yandex/${{ secrets.YC_REGISTRY_ID }}/hsk-backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: üîÑ Checkout code
      uses: actions/checkout@v4
      
    - name: üîß Setup Yandex Cloud CLI
      uses: yc-actions/yc-cli-install@v2
      with:
        yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
        
    - name: üê≥ Login to Container Registry
      run: yc container registry configure-docker
      
    - name: üè∑Ô∏è Generate image tag
      id: image_tag
      run: |
        echo "IMAGE_TAG_FULL=${IMAGE_TAG}:${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
        echo "IMAGE_TAG_LATEST=${IMAGE_TAG}:latest" >> $GITHUB_OUTPUT
        
    - name: üî® Build Docker image
      run: |
        cd backend
        docker build \
          --tag ${{ steps.image_tag.outputs.IMAGE_TAG_FULL }} \
          --tag ${{ steps.image_tag.outputs.IMAGE_TAG_LATEST }} \
          --build-arg NODE_ENV=production \
          .
          
    - name: üß™ Test Docker image
      run: |
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        docker run -d \
          --name test-container \
          -p 3000:8080 \
          -e NODE_ENV=production \
          -e PORT=8080 \
          -e API_KEY=test_key \
          ${{ steps.image_tag.outputs.IMAGE_TAG_FULL }}
        
        # –ñ–¥–µ–º –∑–∞–ø—É—Å–∫–∞
        sleep 10
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º health endpoint
        if curl -f http://localhost:3000/health; then
          echo "‚úÖ Health check passed"
        else
          echo "‚ùå Health check failed"
          docker logs test-container
          exit 1
        fi
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        docker stop test-container
        docker rm test-container
        
    - name: üì§ Push to Container Registry
      run: |
        docker push ${{ steps.image_tag.outputs.IMAGE_TAG_FULL }}
        docker push ${{ steps.image_tag.outputs.IMAGE_TAG_LATEST }}
        
    - name: üîç Check if VM exists
      id: vm_check
      run: |
        if yc compute instance get $VM_NAME >/dev/null 2>&1; then
          echo "VM_EXISTS=true" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è VM $VM_NAME already exists"
        else
          echo "VM_EXISTS=false" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è VM $VM_NAME does not exist"
        fi
        
    - name: üîÑ Update existing VM
      if: steps.vm_check.outputs.VM_EXISTS == 'true'
      run: |
        echo "üîÑ Updating existing VM..."
        yc compute instance update-container $VM_NAME \
          --container-image ${{ steps.image_tag.outputs.IMAGE_TAG_LATEST }} \
          --container-env NODE_ENV=production,PORT=8080,TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }},FRONTEND_URL=${{ secrets.FRONTEND_URL }},API_KEY=${{ secrets.API_KEY }},REQUIRED_CHANNELS=${{ secrets.REQUIRED_CHANNELS }} \
          --container-restart-policy always
          
    - name: üöÄ Create new VM
      if: steps.vm_check.outputs.VM_EXISTS == 'false'
      run: |
        echo "üöÄ Creating new VM..."
        yc compute instance create \
          --name $VM_NAME \
          --zone ru-central1-a \
          --network-interface subnet-name=default-ru-central1-a,nat-ip-version=ipv4 \
          --create-boot-disk image-folder-id=standard-images,image-family=container-optimized-image,size=20GB \
          --cores 2 \
          --memory 2GB \
          --container-name hsk-app \
          --container-image ${{ steps.image_tag.outputs.IMAGE_TAG_LATEST }} \
          --container-env NODE_ENV=production,PORT=8080,TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }},FRONTEND_URL=${{ secrets.FRONTEND_URL }},API_KEY=${{ secrets.API_KEY }},REQUIRED_CHANNELS=${{ secrets.REQUIRED_CHANNELS }} \
          --container-restart-policy always \
          --labels project=hsk,environment=production
          
    - name: üåê Get VM IP address
      id: vm_ip
      run: |
        VM_IP=$(yc compute instance get $VM_NAME --format json | jq -r '.network_interfaces[0].primary_v4_address.one_to_one_nat.address')
        echo "VM_IP=$VM_IP" >> $GITHUB_OUTPUT
        echo "üåê VM IP address: $VM_IP"
        
    - name: ‚è≥ Wait for application startup
      run: |
        echo "‚è≥ Waiting for application to start..."
        sleep 60
        
    - name: üîç Health check
      run: |
        VM_IP=${{ steps.vm_ip.outputs.VM_IP }}
        HEALTH_URL="http://$VM_IP:8080/health"
        
        echo "üîç Checking application health at $HEALTH_URL"
        
        # –ü–æ–ø—ã—Ç–∫–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å –ø–æ–≤—Ç–æ—Ä–∞–º–∏
        for i in {1..5}; do
          if curl -f --connect-timeout 10 --max-time 30 "$HEALTH_URL"; then
            echo "‚úÖ Health check passed on attempt $i"
            break
          else
            echo "‚ö†Ô∏è Health check failed on attempt $i"
            if [ $i -eq 5 ]; then
              echo "‚ùå All health check attempts failed"
              echo "üìã VM logs:"
              yc compute instance get-serial-port-output $VM_NAME --lines 50
              exit 1
            fi
            sleep 15
          fi
        done
        
    - name: üß™ API endpoint test
      run: |
        VM_IP=${{ steps.vm_ip.outputs.VM_IP }}
        API_URL="http://$VM_IP:8080/api/subscription/channels"
        
        echo "üß™ Testing API endpoint: $API_URL"
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º API endpoint
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "x-api-key: ${{ secrets.API_KEY }}" \
          --connect-timeout 10 \
          --max-time 30 \
          "$API_URL")
          
        if [ "$HTTP_STATUS" -eq 200 ]; then
          echo "‚úÖ API endpoint test passed (HTTP $HTTP_STATUS)"
        else
          echo "‚ö†Ô∏è API endpoint returned HTTP $HTTP_STATUS"
          # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –¥–µ–ø–ª–æ–π, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω–æ —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ Telegram
        fi
        
    - name: üìä Deployment summary
      run: |
        VM_IP=${{ steps.vm_ip.outputs.VM_IP }}
        
        echo "## üéâ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| VM Name | $VM_NAME |" >> $GITHUB_STEP_SUMMARY
        echo "| VM IP | $VM_IP |" >> $GITHUB_STEP_SUMMARY
        echo "| Image | ${{ steps.image_tag.outputs.IMAGE_TAG_LATEST }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Branch | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîó Useful Links" >> $GITHUB_STEP_SUMMARY
        echo "- **API Health Check**: http://$VM_IP:8080/health" >> $GITHUB_STEP_SUMMARY
        echo "- **API Endpoint**: http://$VM_IP:8080/api/subscription/channels" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìù Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Update frontend configuration with new API URL" >> $GITHUB_STEP_SUMMARY
        echo "2. Update Telegram bot webhook URL" >> $GITHUB_STEP_SUMMARY
        echo "3. Test all application features" >> $GITHUB_STEP_SUMMARY
        
    - name: üí¨ Notify on failure
      if: failure()
      run: |
        echo "‚ùå Deployment failed!"
        echo "üìã Recent VM logs:"
        yc compute instance get-serial-port-output $VM_NAME --lines 100 || echo "Could not retrieve logs"
        
  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    
    steps:
    - name: üßπ Cleanup old images
      uses: yc-actions/yc-cli-install@v2
      with:
        yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
        
    - name: üóëÔ∏è Remove old container images
      run: |
        echo "üóëÔ∏è Cleaning up old images..."
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –æ–±—Ä–∞–∑–æ–≤
        IMAGES=$(yc container image list --repository-name cr.yandex/${{ secrets.YC_REGISTRY_ID }}/hsk-backend --format json)
        
        # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –æ–±—Ä–∞–∑–æ–≤
        echo "$IMAGES" | jq -r 'sort_by(.created_at) | reverse | .[5:] | .[].id' | while read -r IMAGE_ID; do
          if [ -n "$IMAGE_ID" ]; then
            echo "Deleting image: $IMAGE_ID"
            yc container image delete "$IMAGE_ID" || echo "Failed to delete $IMAGE_ID"
          fi
        done
        
        echo "‚úÖ Cleanup completed"