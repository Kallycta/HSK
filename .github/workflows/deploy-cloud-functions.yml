name: Deploy to Yandex Cloud Functions

on:
  push:
    branches: [ main, master ]
    paths: 
      - 'backend/**'
      - 'functions/**'
      - '.github/workflows/deploy-cloud-functions.yml'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'backend/**'
      - 'functions/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
  YC_SERVICE_ACCOUNT_ID: ${{ secrets.YC_SERVICE_ACCOUNT_ID }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  API_KEY: ${{ secrets.API_KEY }}
  REQUIRED_CHANNELS: ${{ secrets.REQUIRED_CHANNELS }}

jobs:
  # Проверка и тестирование кода
  test:
    name: 🧪 Test Code
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && !inputs.skip_tests)
    
    steps:
    - name: 🔄 Checkout code
      uses: actions/checkout@v4
      
    - name: 🔧 Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: functions/package.json
        
    - name: 📦 Install dependencies
      run: |
        cd functions
        npm install
        
    - name: 🔍 Lint code
      run: |
        cd functions
        npm run lint || echo "Linting warnings found"
        
    - name: 🧪 Run tests
      run: |
        cd functions
        npm test || echo "No tests configured"
        
    - name: 📊 Code analysis
      run: |
        echo "## 📊 Code Analysis Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| File | Size | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|------|------|--------|" >> $GITHUB_STEP_SUMMARY
        
        cd functions
        for file in *.js; do
          size=$(wc -c < "$file")
          if [ $size -gt 10000 ]; then
            status="⚠️ Large"
          else
            status="✅ OK"
          fi
          echo "| $file | ${size} bytes | $status |" >> $GITHUB_STEP_SUMMARY
        done

  # Развертывание на Yandex Cloud Functions
  deploy:
    name: 🚀 Deploy to Yandex Cloud Functions
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped') && github.ref == 'refs/heads/main'
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.gateway_url }}
    
    outputs:
      gateway_url: ${{ steps.deploy.outputs.gateway_url }}
      api_function_id: ${{ steps.deploy.outputs.api_function_id }}
      webhook_function_id: ${{ steps.deploy.outputs.webhook_function_id }}
    
    steps:
    - name: 🔄 Checkout code
      uses: actions/checkout@v4
      
    - name: 🔧 Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: functions/package.json
        
    - name: 🔧 Setup Yandex Cloud CLI
      run: |
        curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
        echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
        
    - name: 🔐 Configure Yandex Cloud CLI
      run: |
        echo '${{ secrets.YC_SA_JSON_CREDENTIALS }}' > key.json
        yc config profile create sa-profile
        yc config set service-account-key key.json
        yc config set folder-id ${{ secrets.YC_FOLDER_ID }}
        rm key.json
        
    - name: 📦 Install production dependencies
      timeout-minutes: 10
      run: |
        cd functions
        
        # Удаляем существующие node_modules для чистой установки
        rm -rf node_modules/
        
        # Устанавливаем только production зависимости
        npm ci --only=production --silent --no-audit --no-fund
        
        # Удаляем все dev зависимости и кэш
        npm prune --production
        npm cache clean --force
        
        # Удаляем ненужные файлы из node_modules
        find node_modules/ -name "*.md" -delete
        find node_modules/ -name "*.txt" -delete
        find node_modules/ -name "CHANGELOG*" -delete 2>/dev/null || true
        find node_modules/ -name "LICENSE*" -delete 2>/dev/null || true
        find node_modules/ -name "HISTORY*" -delete 2>/dev/null || true
        find node_modules/ -name "*.d.ts" -delete 2>/dev/null || true
        find node_modules/ -name "*.map" -delete 2>/dev/null || true
        find node_modules/ -name "*.min.js.map" -delete 2>/dev/null || true
        find node_modules/ -name "CONTRIBUTORS*" -delete 2>/dev/null || true
        find node_modules/ -name "AUTHORS*" -delete 2>/dev/null || true
        find node_modules/ -name "MAINTAINERS*" -delete 2>/dev/null || true
        find node_modules/ -name "*.test.js" -delete
        find node_modules/ -name "*.spec.js" -delete
        
        # Удаляем ненужные директории
        find node_modules/ -name "test" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "tests" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "example" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "examples" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "docs" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "doc" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "coverage" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "benchmark" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "perf" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "demo" -type d -exec rm -rf {} + 2>/dev/null || true
        find node_modules/ -name "sample" -type d -exec rm -rf {} + 2>/dev/null || true
        rm -rf node_modules/.cache/
        rm -rf node_modules/.bin/
        
        # Проверяем размер node_modules
        NODE_MODULES_SIZE=$(du -sm node_modules/ | cut -f1)
        echo "📦 node_modules size: ${NODE_MODULES_SIZE} MB"
        
    - name: 🗜️ Create deployment package
      run: |
        cd functions
        
        # Создаем архив с исключением ненужных файлов (используем .yandexignore)
        zip -r ../functions.zip . \
          -x "node_modules/.cache/*" \
             "node_modules/.bin/*" \
             "*.log" \
             "test/*" \
             "tests/*" \
             "*.test.js" \
             "*.spec.js" \
             ".git/*" \
             "README.md" \
             "*.md" \
             "package-lock.json"
        
        # Проверяем размер архива
        ARCHIVE_SIZE=$(stat -c%s "../functions.zip")
        ARCHIVE_SIZE_MB=$(echo "scale=2; $ARCHIVE_SIZE / 1024 / 1024" | bc)
        
        echo "📦 Archive size: ${ARCHIVE_SIZE_MB} MB"
        
        # Yandex Cloud Functions лимит: 3.5 MB
        if (( $(echo "$ARCHIVE_SIZE_MB > 3.5" | bc -l) )); then
          echo "❌ ERROR: Archive size ${ARCHIVE_SIZE_MB} MB exceeds Yandex Cloud Functions limit of 3.5 MB"
          echo "💡 Try optimizing dependencies or use Object Storage for larger functions"
          
          # Показываем самые большие файлы в архиве
          echo "📊 Largest files in archive:"
          unzip -l ../functions.zip | sort -k1 -nr | head -10
          
          exit 1
        fi
        
        echo "✅ Archive size is within 3.5 MB limit"
        echo "archive_size=${ARCHIVE_SIZE_MB}" >> $GITHUB_OUTPUT
        
    - name: 🚀 Deploy API Function
      id: deploy_api
      run: |
        echo "🚀 Deploying API Function..."
        
        # Проверяем существование функции
        if yc serverless function get hsk-api-function >/dev/null 2>&1; then
          echo "📝 Function exists, creating new version"
        else
          echo "🆕 Creating new function"
          yc serverless function create \
            --name hsk-api-function \
            --description "HSK Telegram Bot API endpoints"
        fi
        
        # Создаем новую версию функции
        yc serverless function version create \
          --function-name hsk-api-function \
          --runtime nodejs18 \
          --entrypoint api-handler.handler \
          --memory 256m \
          --execution-timeout 30s \
          --source-path functions.zip \
          --environment NODE_ENV=${{ github.event.inputs.environment || 'production' }},TELEGRAM_BOT_TOKEN=${{ env.TELEGRAM_BOT_TOKEN }},API_KEY=${{ env.API_KEY }},REQUIRED_CHANNELS="${{ env.REQUIRED_CHANNELS }}"
        
        # Получаем ID функции
        API_FUNCTION_ID=$(yc serverless function get hsk-api-function --format json | jq -r '.id')
        echo "api_function_id=${API_FUNCTION_ID}" >> $GITHUB_OUTPUT
        echo "✅ API Function deployed: ${API_FUNCTION_ID}"
        
    - name: 🚀 Deploy Telegram Webhook Function
      id: deploy_webhook
      run: |
        echo "🚀 Deploying Telegram Webhook Function..."
        
        # Проверяем существование функции
        if yc serverless function get hsk-telegram-webhook >/dev/null 2>&1; then
          echo "📝 Function exists, creating new version"
        else
          echo "🆕 Creating new function"
          yc serverless function create \
            --name hsk-telegram-webhook \
            --description "HSK Telegram Bot webhook handler"
        fi
        
        # Создаем новую версию функции
        yc serverless function version create \
          --function-name hsk-telegram-webhook \
          --runtime nodejs18 \
          --entrypoint telegram-webhook.handler \
          --memory 128m \
          --execution-timeout 15s \
          --source-path functions.zip \
          --environment NODE_ENV=${{ github.event.inputs.environment || 'production' }},TELEGRAM_BOT_TOKEN=${{ env.TELEGRAM_BOT_TOKEN }}
        
        # Получаем ID функции
        WEBHOOK_FUNCTION_ID=$(yc serverless function get hsk-telegram-webhook --format json | jq -r '.id')
        echo "webhook_function_id=${WEBHOOK_FUNCTION_ID}" >> $GITHUB_OUTPUT
        echo "✅ Webhook Function deployed: ${WEBHOOK_FUNCTION_ID}"
        
    - name: 🌐 Deploy API Gateway
      id: deploy_gateway
      run: |
        echo "🌐 Deploying API Gateway..."
        
        # Получаем ID функций
        API_FUNCTION_ID="${{ steps.deploy_api.outputs.api_function_id }}"
        WEBHOOK_FUNCTION_ID="${{ steps.deploy_webhook.outputs.webhook_function_id }}"
        
        # Обновляем спецификацию API Gateway
        sed "s/<API_FUNCTION_ID>/${API_FUNCTION_ID}/g" api-gateway-spec.yaml > api-gateway-spec-temp.yaml
        sed -i "s/<TELEGRAM_WEBHOOK_FUNCTION_ID>/${WEBHOOK_FUNCTION_ID}/g" api-gateway-spec-temp.yaml
        sed -i "s/<SERVICE_ACCOUNT_ID>/${{ env.YC_SERVICE_ACCOUNT_ID }}/g" api-gateway-spec-temp.yaml
        
        # Проверяем существование API Gateway
        if yc serverless api-gateway get hsk-api-gateway >/dev/null 2>&1; then
          echo "📝 API Gateway exists, updating"
          yc serverless api-gateway update hsk-api-gateway \
            --spec api-gateway-spec-temp.yaml
        else
          echo "🆕 Creating new API Gateway"
          yc serverless api-gateway create \
            --name hsk-api-gateway \
            --description "HSK Telegram Bot API Gateway" \
            --spec api-gateway-spec-temp.yaml
        fi
        
        # Получаем URL API Gateway
        GATEWAY_DOMAIN=$(yc serverless api-gateway get hsk-api-gateway --format json | jq -r '.domain')
        GATEWAY_URL="https://${GATEWAY_DOMAIN}"
        
        echo "gateway_url=${GATEWAY_URL}" >> $GITHUB_OUTPUT
        echo "✅ API Gateway deployed: ${GATEWAY_URL}"
        
    - name: 🔗 Setup Telegram Webhook
      run: |
        echo "🔗 Setting up Telegram webhook..."
        
        GATEWAY_URL="${{ steps.deploy_gateway.outputs.gateway_url }}"
        WEBHOOK_URL="${GATEWAY_URL}/webhook/telegram"
        
        # Устанавливаем webhook
        RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/setWebhook" \
          -H "Content-Type: application/json" \
          -d "{
            \"url\": \"${WEBHOOK_URL}\",
            \"allowed_updates\": [\"message\", \"callback_query\"]
          }")
        
        # Проверяем результат
        if echo "$RESPONSE" | jq -r '.ok' | grep -q true; then
          echo "✅ Telegram webhook set: ${WEBHOOK_URL}"
        else
          echo "❌ Failed to set Telegram webhook"
          echo "Response: $RESPONSE"
          exit 1
        fi
        
    - name: 🔍 Test deployment
      id: test_deployment
      run: |
        echo "🔍 Testing deployment..."
        
        GATEWAY_URL="${{ steps.deploy_gateway.outputs.gateway_url }}"
        
        # Тест health endpoint
        echo "Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -s -f "${GATEWAY_URL}/health" || echo "failed")
        
        if echo "$HEALTH_RESPONSE" | jq -r '.status' | grep -q ok; then
          echo "✅ Health check: PASSED"
          echo "health_status=passed" >> $GITHUB_OUTPUT
        else
          echo "❌ Health check: FAILED"
          echo "Response: $HEALTH_RESPONSE"
          echo "health_status=failed" >> $GITHUB_OUTPUT
        fi
        
        # Тест API endpoint
        echo "Testing API endpoint..."
        API_RESPONSE=$(curl -s -f -H "x-api-key: ${{ env.API_KEY }}" "${GATEWAY_URL}/api/subscription/channels" || echo "failed")
        
        if echo "$API_RESPONSE" | jq -r '.success' | grep -q true; then
          CHANNELS_COUNT=$(echo "$API_RESPONSE" | jq -r '.total')
          echo "✅ API test: PASSED (${CHANNELS_COUNT} channels found)"
          echo "api_status=passed" >> $GITHUB_OUTPUT
        else
          echo "⚠️ API test: WARNING"
          echo "Response: $API_RESPONSE"
          echo "api_status=warning" >> $GITHUB_OUTPUT
        fi
        
    - name: 📊 Deployment summary
      run: |
        GATEWAY_URL="${{ steps.deploy_gateway.outputs.gateway_url }}"
        
        echo "## 🎉 Cloud Functions Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📋 Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Environment | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Node.js Version | ${{ env.NODE_VERSION }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Archive Size | ${{ steps.create_package.outputs.archive_size }} MB |" >> $GITHUB_STEP_SUMMARY
        echo "| API Function ID | ${{ steps.deploy_api.outputs.api_function_id }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Webhook Function ID | ${{ steps.deploy_webhook.outputs.webhook_function_id }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔗 Endpoints" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Endpoint | URL | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| API Gateway | ${GATEWAY_URL} | ✅ Active |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Check | ${GATEWAY_URL}/health | ${{ steps.test_deployment.outputs.health_status == 'passed' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| API Endpoint | ${GATEWAY_URL}/api/subscription/channels | ${{ steps.test_deployment.outputs.api_status == 'passed' && '✅ Passed' || steps.test_deployment.outputs.api_status == 'warning' && '⚠️ Warning' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Telegram Webhook | ${GATEWAY_URL}/webhook/telegram | ✅ Configured |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📝 Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "1. Test the Telegram bot by sending /start command" >> $GITHUB_STEP_SUMMARY
        echo "2. Monitor function logs in Yandex Cloud Console" >> $GITHUB_STEP_SUMMARY
        echo "3. Check API Gateway metrics" >> $GITHUB_STEP_SUMMARY
        echo "4. Update frontend BACKEND_URL to: ${GATEWAY_URL}" >> $GITHUB_STEP_SUMMARY
        
    - name: 🧹 Cleanup
      if: always()
      run: |
        echo "🧹 Cleaning up temporary files..."
        rm -f functions.zip
        rm -f api-gateway-spec-temp.yaml
        echo "✅ Cleanup completed"

  # Мониторинг после развертывания
  monitor:
    name: 📊 Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success() && github.ref == 'refs/heads/main'
    
    steps:
    - name: 🔧 Setup Yandex Cloud CLI
      run: |
        curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
        echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
        
    - name: 🔐 Configure Yandex Cloud CLI
      run: |
        echo '${{ secrets.YC_SA_JSON_CREDENTIALS }}' > key.json
        yc config profile create sa-profile
        yc config set service-account-key key.json
        yc config set folder-id ${{ secrets.YC_FOLDER_ID }}
        rm key.json
        
    - name: 📊 Check function metrics
      run: |
        echo "📊 Checking function metrics..."
        
        # Получаем статистику функций
        echo "## 📊 Function Statistics" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        for func_name in "hsk-api-function" "hsk-telegram-webhook"; do
          echo "### ${func_name}" >> $GITHUB_STEP_SUMMARY
          
          # Получаем информацию о функции
          FUNC_INFO=$(yc serverless function get $func_name --format json)
          
          MEMORY=$(echo "$FUNC_INFO" | jq -r '.resources.memory')
          TIMEOUT=$(echo "$FUNC_INFO" | jq -r '.timeout')
          RUNTIME=$(echo "$FUNC_INFO" | jq -r '.runtime')
          
          echo "- Memory: ${MEMORY}" >> $GITHUB_STEP_SUMMARY
          echo "- Timeout: ${TIMEOUT}" >> $GITHUB_STEP_SUMMARY
          echo "- Runtime: ${RUNTIME}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        done
        
    - name: 📋 Get recent logs
      run: |
        echo "📋 Getting recent function logs..."
        
        for func_name in "hsk-api-function" "hsk-telegram-webhook"; do
          echo "\n=== Logs for ${func_name} ==="
          
          FUNC_ID=$(yc serverless function get $func_name --format json | jq -r '.id')
          
          # Получаем логи за последние 10 минут
          yc logging read \
            --group-name default \
            --resource-type serverless.function \
            --resource-id $FUNC_ID \
            --since 10m \
            --limit 20 || echo "No recent logs found"
        done

  # Уведомление об успешном развертывании
  notify:
    name: 📢 Notify Success
    runs-on: ubuntu-latest
    needs: [deploy, monitor]
    if: success() && github.ref == 'refs/heads/main'
    
    steps:
    - name: 📢 Success notification
      run: |
        echo "🎉 HSK Telegram Bot successfully deployed to Yandex Cloud Functions!"
        echo "Gateway URL: ${{ needs.deploy.outputs.gateway_url }}"
        echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
        echo "Commit: ${{ github.sha }}"
        
        # Здесь можно добавить отправку уведомлений в Slack, Discord, etc.
        # Например:
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"🎉 HSK Bot deployed successfully!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}